\chapter{Conclusion}

In Chapter~\ref{pu_1d} we created a new method that offers a simple way to adaptively construct infinitely smooth approximations of functions that are given explicitly or that solve BVPs. We created a new way to implicitly construct a partition of unity recursively with a binary tree, allowing us to avoid the need to determine neighbors of each patch. This makes using a partition of unity scheme effective within a adaptive scheme; for example, when adaptively solving a BVP we can avoid having to redetermine neighboring patches with  our new technique. 

We extend the tree based approximations to arbitrary dimension in Chapter~\ref{pu_nd}, allowing us to construct approximations that are adapted to the features of the function but still infinitely smooth. We utilized the tree structure to develop fast algorithms for integration, differentiation and interpolation. The tree structure gives a fast way to arithmetically combine partition of unity approximations by merging their splittings; it is not clear how this could be done with a partition of unity approximation represented with a graph (i.e., a data structure where a patch points to its neighbors). We extended this technique to arbitrary domains via the least squares technique. 

In Chapter~\ref{snk_chap} we described a framework for overlapping domain decomposition in which overlap regions are discretized independently by the local subdomains, even in the formulation of the global problem. Communication between subdomains occurs only via interpolation of values to interface points. This formulation makes it straightforward to apply high-order or spectral discretization methods in the subdomains and to adaptively refine them. The technique may be applied to precondition a linearized PDE, but it may also be used to precondition the nonlinear problem before linearization, to get what we call the Schwarz--Newton--Krylov (SNK) technique. In doing so, one gets the same benefit of faster Krylov inner convergence, but the resulting nonlinear problem is demonstrably easier to solve in terms of outer iterations and robustness. 

We apply SNK to solve a blinking eye model in Chapter~\ref{chap_eye}. Domain decomposition allows us to achieve the necessary resolution to perserve the volume over a blink cycle in a way that is computationally efficient. We discovered through numerical experiments that the influx and outflux conditions (\ref{influx_fun},\ref{out_flux_fun}) could be causing the tear film thickness to become negative, producing unrealistic results. Further examination and experimentation is needed to validate the model.

The partition of unity techniques we presented in Chapter~\ref{pu_nd} allow for the possibility of parallelization. In particular our methods for adaptive construction could be sped up, since no communication is needed between subdomains in further refinement (i.e. once a domain is split, no communication is needed in between the resulting subdomains in further refinements). We explored how to parallelize our new SNK method using {\tt parfor} loop in MATLAB, and found that it can offer some potential speed benefits. With SNK, the only communication between subdomains that is necessary is through the interface conditions. Work should be done to explore a technique that can take advantage of this (since {\tt parfor} does not).


