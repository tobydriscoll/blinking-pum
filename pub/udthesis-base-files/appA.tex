%
% This is the Appendix A file (appA.tex)
%
\appendix{Merging trees}
\label{sec:merge}

Algorithm~\ref{alg:merge} describes a recursive method for merging two trees $\ct_1$ and $\ct_2$, representing functions $f_1$ and $f_2$, into a tree representation for $f_1\circ f_2$, with $\circ$ as $+$, $-$, $\times$, or $\div$. The input arguments to the algorithm are the operation, corresponding nodes of $\ct_1$, $\ct_2$, and the merged tree, and the number $r$, which is the dimension that was most recently split in the merged tree. Initially the algorithm is called with root nodes representing the entire original domain, and $r=0$. 

We assume an important relationship among the input nodes. Suppose that \prop{zone}{$\nu_k$}=$\prod_{j=1}^d [\alpha_{kj},\beta_{kj}]$ for $k=1,2$, and that \prop{zone}{$\Tm$}=$\prod_{j=1}^d [A_{j},B_{j}]$. Then we require for $k=1,2$ that
\begin{equation}
  \label{eq:merge-zones}
  [a_{kj},b_{kj}]=[A_j,B_j] \quad \text{for all $j$ having} \quad   \prop{isdone}{\nu_k}_j=
  \text{FALSE}.
\end{equation}
This is trivially true at the root level. The significance of this requirement is that it allows us to avoid ambiguity about what the zone of $\Tm$ should be after a new split in, say, dimension $j$. Since only an uncompleted dimension can be split, the zone of the children of $\Tm$ after splitting will be identical to that of whichever (or both) of the $\nu_k$ requires refinement in dimension $j$.

For example, suppose the zones of $\nu_1$ and $\nu_2$ are $[-1,0]\times[-1,1]$ and $[-1,1]\times[0,1]$, respectively, and \prop{zone}{$\Tm$}=$[-1,0]\times[0,1]$. It is clear that we can interpolate from $\nu_1$ and $\nu_2$ onto $\Tm$. It is also clear that we can further split in $x$ in $\nu_1$, and in $y$ in $\nu_2$. But if we were to split $\nu_2$ in $x$, one of the children would have zone $[0,1]\times[0,1]$, which is inaccessible to $\nu_1$. 

Consider the general recursive call. If both $\nu_1$ and $\nu_2$ are leaves, then we simply evaluate the result of operating on their interpolants to get the values on $\Tm$. If exactly one of $\nu_1$ and $\nu_2$ is a leaf, then we split $\Tm$ the same way as the non-leaf and recurse into the resulting children; property~(\ref{eq:merge-zones}) trivially remains true in these calls. If both  $\nu_1$ and $\nu_2$ are non-leaves, and they both split in the same dimension, then we can split $\Tm$ in that dimension and recurse, and the zones will continue to match as in~(\ref{eq:merge-zones}).

The only remaining case is that $\nu_1$ and $\nu_2$ are each split, but in different dimensions. In this case we have to use information about how the splittings are constructed in Algorithm~\ref{alg:refine}. Recall that each unresolved dimension is split in order, while resolved dimensions are flagged as finished in all descendants. By inductive assumption, $\Tm$ was most recently split in dimension $r$. The algorithm determines which $\nu_k$ has splitting dimension $j$ that comes the soonest after $r$ (computed cyclically). Thus for all dimensions between $r$ and $j$, neither of the given nodes splits, so it and its descendants all must have \textsf{isdone} set to TRUE in those dimensions, and property~(\ref{eq:merge-zones}) makes no requirement. Furthermore, the dimension $r_k$ does satisfy~(\ref{eq:merge-zones}) for $\nu_k$, and the same will be true for its children and the children of $\Tm$. All other dimensions will inherit~(\ref{eq:merge-zones}) from the parents. 


\newcommand{\op}{\ensuremath{\circ}}
\begin{algorithm}[!h]
\caption{merge(\op,$\nu_1$,$\nu_2$,$\num$,$r$)}
\label{alg:merge}
\begin{algorithmic}
\IF{$\nu_1$ and $\nu_2$ are leaves}
\STATE \textsf{values}($\num$):= \textsf{interpolant}($\nu_1$) $\op$ \textsf{interpolant}($\nu_2$), evaluated on \prop{grid}{$T_\text{merge}$}
\ELSIF{$\nu_1$ is a leaf \AND $\nu_2$ is not a leaf}
\STATE split($\num$,\prop{splitdim}{$\nu_1$})
\STATE merge(\op,$\nu_1$,\child{0}($\nu_2$),\child{0}($\num$),\prop{splitdim}{$\nu_2$})
\STATE merge(\op,$\nu_1$,\child{1}($\nu_2$),\child{1}($\num$),\prop{splitdim}{$\nu_2$})
\ELSIF{$\nu_1$ is not a leaf \AND $\nu_2$ is a leaf}
\STATE split($\num$,\prop{splitdim}{$\nu_1$})
\STATE merge(\child{0}($\nu_1$),$\nu_2$,\child{0}($\num$),\prop{splitdim}{$\nu_1$})
\STATE merge(\child{1}($\nu_1$),$\nu_2$,\child{1}($\num$),\prop{splitdim}{$\nu_1$})
\ELSE
\IF{\prop{splitdim}{$\nu_1$}=\prop{splitdim}{$\nu_2$}}
\STATE split($\num$,\prop{splitdim}{$\nu_1$})
\STATE merge(\op,\child{0}($\nu_1$),\child{0}($\nu_2$),\child{0}($\num$),\prop{splitdim}{$\nu_1$})
\STATE merge(\op,\child{1}($\nu_1$),\child{1}($\nu_2$),\child{1}($\num$),\prop{splitdim}{$\nu_1$})
\ELSE
\STATE $r_1 = (\text{\prop{splitdim}{$\nu_1$}}-r-1) \mod d$
\STATE $r_2 = (\text{\prop{splitdim}{$\nu_2$}}-r-1) \mod d$
\STATE If $r_1>r_2$, swap $\nu_1$ and $\nu_2$
\STATE split($\Tm$,\prop{splitdim}{$\nu_1$})
\STATE merge(\op,\child{0}($\nu_1$),$\nu_2$,\child{0}($\num$),\prop{splitdim}{$\nu_1$})
\STATE merge(\op,\child{1}($\nu_1$),$\nu_2$,\child{1}($\num$), \prop{splitdim}{$\nu_1$})
\ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}